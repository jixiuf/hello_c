//file name : pipe.c
//created at: 2012年05月02日 星期三 01时25分10秒
//author:  纪秀峰

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char *argv[]){
  int fd[2],c;
  pid_t pid;
  char* str[10];
  if(pipe(fd)<0){
    perror("pipe");
    exit(1);
  }
  if ((pid= fork())<0){
    perror("fork error");
    exit(1);
  }
  if (pid==0){                   /* child process */
    close(fd[1]);
    c=read(fd[0],str,10);
    write(STDOUT_FILENO,str,c);
  }else{                        /* pid>0, parent process */
    close(fd[0]);
    write(fd[1],"hello\n",6);
    wait(NULL);

  }

  return 0;
}

/* #include <unistd.h> */
/* int pipe(int filedes[2]); */
/* 通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区 */



/* 使用管道有一些限制： */
/*     两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，
       如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只
       开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，
       为什么不能实现双向通信？ */
/*     管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的
       公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程
       之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，
       然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问
       同一管道，它们才能通信。 */
/* 使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标
   志）： */
/*     如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而
       仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会
       返回0，就像读到文件末尾一样。 */
/*     如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有
       管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道
       中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据
       并返回。 */
/*     如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这
       时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异
       常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。 */
/*     如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有
       管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管
       道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。 */
/* 管道的这四种特殊情况具有普遍意义。在第 37 章 socket编程要讲的TCP socket也具
   有管道的这些特性。 */
